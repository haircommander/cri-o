package resourcecache

import (
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
)

var sleepTimeBeforeCleanup = 2 * time.Minute

// ResourceCache is a structure that saves information about a nearly created resource.
// Items can be added and retrieved from the cache. A retrieval (GetResourceFromCache) also removes the item from the cache.
// If `sleepTimeBeforeCleanup` has passed, and the resource has not yet been retrieved, ResourceCache considers that item stale,
// and removes it.
type ResourceCache struct {
	resources map[string]*Resource
	sync.Mutex
}

// Resource contains the actual resource itself (which must implement the IdentifiableCreatable interface),
// as well as stores function pointers that pertain to how that resource should be cleaned up.
type Resource struct {
	resource     IdentifiableCreatable
	cleanupFuncs []func()
	watchers []chan struct{}
}

// IdentifiableCreatable are the qualities needed by the caller of the item.
// Once an item is retrieved, SetCreated() will be called, indicating to the server
// that that item is ready to be listed and operated upon, and ID() will be used to identify the
// newly created resource to the server.
type IdentifiableCreatable interface {
	ID() string
	SetCreated()
}

// New creates a new ResourceCache
func New() *ResourceCache {
	rc := &ResourceCache{
		resources: make(map[string]*Resource),
	}
	return rc
}

// AddResourceToCache takes a unique resource name (retrieved from the client request, not generated by the server)
// a newly created resource, and functions to cleanup that newly created resource.
// It adds the Resource to the ResourceCache, as well as starts a go routine that is responsible for cleaning up the
// resource if the server has not gotten another request for it (i.e. if GetResourceFromCache has not been called).
// AddResourceToCache expects `name`s passed to it to be unique. If a duplicate `name` is detected, it returns an error.
func (rc *ResourceCache) AddResourceToCache(name string, resource IdentifiableCreatable, cleanupFuncs []func()) error {
	rc.Lock()
	defer rc.Unlock()

	r, ok := rc.resources[name]
	// if we don't already have a resource, create it
	if !ok {
		r = &Resource{}
		rc.resources[name] = r
	}
	// make sure the resource hasn't already been added to the cache
	if r.resource != nil || r.cleanupFuncs != nil {
		return errors.Errorf("failed to add entry %s to ResourceCache; entry already exists", name)
	}

	r.resource = resource
	r.cleanupFuncs = cleanupFuncs
	go rc.cleanupResourceAfterSleep(name)

	// now the resource is created, notify the watchers
	for _, w := range r.watchers {
		w<-struct{}{}
	}
	return nil
}

// cleanupResourceAfterSleep sleeps for `sleepTimeBeforeCleanup` and then attempts to
// remove the entry from the ResourceCache.
// To remove the entry, the item is removed from the cache, and its cleanupFuncs are called.
func (rc *ResourceCache) cleanupResourceAfterSleep(name string) {
	time.Sleep(sleepTimeBeforeCleanup)

	rc.Lock()
	r, ok := rc.resources[name]
	if !ok {
		rc.Unlock()
		return
	}
	logrus.Infof("cleaning up %s after kubelet didn't re-request it", name)
	delete(rc.resources, name)
	// no need to hold the lock when running the cleanup functions
	rc.Unlock()

	for _, f := range r.cleanupFuncs {
		f()
	}
}

func (rc *ResourceCache) GetWatcherForResource(name string) chan struct{} {
	rc.Lock()
	defer rc.Unlock()
	watcher := make(chan struct{}, 1)
	r, ok := rc.resources[name]
	if !ok {
		rc.resources[name] = &Resource{
			watchers: []chan struct{}{watcher},
		}
		return watcher
	}
	r.watchers = append(r.watchers, watcher)
	return watcher
}

// GetResourceFromCache attempts to look up a resource by its name.
// If it's found, it's removed from the cache, and it is set as created.
// GetResourceFromCache returns an empty ID if the resource is not found,
// and returns the value of the items ID() method if it is.
func (rc *ResourceCache) GetResourceFromCache(name string) string {
	rc.Lock()
	defer rc.Unlock()

	r, ok := rc.resources[name]
	if !ok {
		return ""
	}
	delete(rc.resources, name)
	r.resource.SetCreated()
	return r.resource.ID()
}
